// Transformation ETL: Input -> Pipeline
// Utilise le preset injecté depuis Java pour les steps

rule TransformJob
    transform sourceJob : Source!Job
    to targetJob : Target!Job {

        targetJob.name = sourceJob.name;
        targetJob.runsOn = sourceJob.runsOn.isDefined() ? sourceJob.runsOn : "ubuntu-latest";

        for (env in sourceJob.envVariables) {
            var targetEnv = new Target!EnvVariable;
            targetEnv.key = env.key;
            targetEnv.value = env.value;
            targetJob.env.add(targetEnv);
        }

        for (need in sourceJob.needs) {
            targetJob.needs.add(need);
        }

        // Step de checkout (toujours ajouté)
        var checkoutStep = new Target!Step;
        checkoutStep.name = "Checkout code";
        checkoutStep.uses = "actions/checkout@v3";
        targetJob.steps.add(checkoutStep);

        // Obtenir les steps du preset injecté
        var jobSteps = getPresetSteps(sourceJob.name);
        for (step in jobSteps) {
            var targetStep = createStepFromPreset(step);
            targetJob.steps.add(targetStep);
        }
    }

rule TransformEvent
    transform sourceEvent : Source!Event
    to targetEvent : Target!Event {

        // Conversion de l'enum du métamodèle source vers le métamodèle cible
        var eventTypeName = sourceEvent.eventType.name;
        if (eventTypeName == "PUSH") {
            targetEvent.eventType = Target!EventType#PUSH;
        } else if (eventTypeName == "PULL_REQUEST") {
            targetEvent.eventType = Target!EventType#PULL_REQUEST;
        }

        for (branch in sourceEvent.branches) {
            var targetBranch = new Target!Branch;
            targetBranch.name = branch.name;
            targetEvent.branches.add(targetBranch);
        }
    }

rule TransformPipeline
    transform source : Source!PipelineInput
    to target : Target!WorkflowFile {

        target.name = source.pipelineName;

        var triggerConfig = new Target!TriggerConfig;
        target.on = triggerConfig;

        for (event in source.events) {
            var transformedEvent = event.equivalent();
            target.on.events.add(transformedEvent);
        }

        for (job in source.jobs) {
            var transformedJob = job.equivalent();
            target.jobs.add(transformedJob);
        }
    }

// Opération pour obtenir les steps du preset en fonction du type de job
operation getPresetSteps(jobName : String) : Sequence {
    // preset est une Map<String, List<Map<String, Object>>> injectée depuis Java
    if (preset.isDefined() and preset.containsKey(jobName)) {
        return preset.get(jobName);
    }
    return new Sequence;
}

// Opération pour créer un Step à partir des données du preset
operation createStepFromPreset(stepData : Any) : Target!Step {
    var step = new Target!Step;

    // Nom du step
    if (stepData.containsKey("name")) {
        step.name = stepData.get("name");
    }

    // Action uses
    if (stepData.containsKey("uses")) {
        step.uses = stepData.get("uses");
    }

    // Commande run
    if (stepData.containsKey("run")) {
        step.run = stepData.get("run");
    }

    // Paramètres with
    if (stepData.containsKey("with")) {
        var withParams = stepData.get("with");
        for (key in withParams.keySet()) {
            var param = new Target!EnvVariable;
            param.key = key;
            param.value = withParams.get(key).asString();
            step.with.add(param);
        }
    }

    return step;
}

